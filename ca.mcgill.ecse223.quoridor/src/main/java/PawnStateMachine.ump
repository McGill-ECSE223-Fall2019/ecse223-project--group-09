namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;

class PawnBehavior {

    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;

    pawnSM {
    }

    // Returns the current row number of the pawn
    int getCurrentPawnRow() {
        final GamePosition gpos = this.getCurrentGame().getCurrentPosition();
        if (this.getPlayer().hasGameAsWhite()) {
            return gpos.getWhitePosition().getTile().getRow();
        } else {
            return gpos.getBlackPosition().getTile().getRow();
        }
    }

    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {
        final GamePosition gpos = this.getCurrentGame().getCurrentPosition();
        if (this.getPlayer().hasGameAsWhite()) {
            return gpos.getWhitePosition().getTile().getColumn();
        } else {
            return gpos.getBlackPosition().getTile().getColumn();
        }
    }

    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) {
        final GamePosition gpos = this.getCurrentGame().getCurrentPosition();

        // If we have a pawn or pawn in the direction we are moving,
        // the step cannot be legal
        switch (dir) {
            case East:
                return QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() + 1)
                    && !QuoridorController.anyWallRightOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case South:
                return QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() - 1, this.getCurrentPawnColumn())
                    && !QuoridorController.anyWallBelowTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case West:
                return QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() - 1)
                    && !QuoridorController.anyWallLeftOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case North:
                return QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() + 1, this.getCurrentPawnColumn())
                    && !QuoridorController.anyWallAboveTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            default:
                throw new IllegalArgumentException("Unknown move direction: " + dir);
        }
    }

    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) {
        final GamePosition gpos = this.getCurrentGame().getCurrentPosition();

        // Two types:
        // - Far jump:
        //   [X O @] where 'X' jumps over 'O' to '@'
        //   [     ]
        // - Lateral jump:
        //   [X O| ] where 'X' moves over 'O' to '@'
        //   [  @  ]

        switch (dir) {
            case East:
                if (!QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() + 1)) {
                    // We expected pawn 'O' and it's not there
                    // Pawn 'X' should not be able to jump
                    return false;
                }
                if (QuoridorController.anyWallRightOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())) {
                    // Nothing can jump over walls
                    return false;
                }

                // This determines if we are far jumping or lateral jumping
                if (QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() + 2)) {
                    if (!QuoridorController.anyWallRightOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() + 1)) {
                        // That means the pawn is eligible for a far jump
                        return true;
                    }
                    // Do not exit here, pawn may still be eligible for a lateral jump
                }

                // Then we are trying to lateral jump
                return !QuoridorController.anyWallAboveTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())
                    || !QuoridorController.anyWallBelowTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case South:
                if (!QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() - 1, this.getCurrentPawnColumn())) {
                    // We expected pawn 'O' and it's not there
                    // Pawn 'X' should not be able to jump
                    return false;
                }
                if (QuoridorController.anyWallBelowTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())) {
                    // Nothing can jump over walls
                    return false;
                }

                // This determines if we are far jumping or lateral jumping
                if (QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() - 2, this.getCurrentPawnColumn())) {
                    if (!QuoridorController.anyWallBelowTile(gpos, this.getCurrentPawnRow() - 1, this.getCurrentPawnColumn())) {
                        // That means the pawn is eligible for a far jump
                        return true;
                    }
                    // Do not exit here, pawn may still be eligible for a lateral jump
                }

                // Then we are trying to lateral jump
                return !QuoridorController.anyWallLeftOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())
                    || !QuoridorController.anyWallRightOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case West:
                if (!QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() - 1)) {
                    // We expected pawn 'O' and it's not there
                    // Pawn 'X' should not be able to jump
                    return false;
                }
                if (QuoridorController.anyWallLeftOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())) {
                    // Nothing can jump over walls
                    return false;
                }

                // This determines if we are far jumping or lateral jumping
                if (QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() - 2)) {
                    if (!QuoridorController.anyWallLeftOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn() - 1)) {
                        // That means the pawn is eligible for a far jump
                        return true;
                    }
                    // Do not exit here, pawn may still be eligible for a lateral jump
                }

                // Then we are trying to lateral jump
                return !QuoridorController.anyWallAboveTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())
                    || !QuoridorController.anyWallBelowTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
            case North:
                if (!QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() + 1, this.getCurrentPawnColumn())) {
                    // We expected pawn 'O' and it's not there
                    // Pawn 'X' should not be able to jump
                    return false;
                }
                if (QuoridorController.anyWallAboveTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())) {
                    // Nothing can jump over walls
                    return false;
                }

                // This determines if we are far jumping or lateral jumping
                if (QuoridorController.validatePawnPlacement(gpos, this.getCurrentPawnRow() + 2, this.getCurrentPawnColumn())) {
                    if (!QuoridorController.anyWallAboveTile(gpos, this.getCurrentPawnRow() + 1, this.getCurrentPawnColumn())) {
                        // That means the pawn is eligible for a far jump
                        return true;
                    }
                    // Do not exit here, pawn may still be eligible for a lateral jump
                }

                // Then we are trying to lateral jump
                return !QuoridorController.anyWallLeftOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn())
                    || !QuoridorController.anyWallRightOfTile(gpos, this.getCurrentPawnRow(), this.getCurrentPawnColumn());
        default:
            throw new IllegalArgumentException("Unknown jump direction: " + dir);
        }
    }

    // Action to be called when an illegal move is attempted
    void illegalMove() {
        throw new IllegalPawnMoveException("Attempted pawn move is illegal!");
    }

    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}
